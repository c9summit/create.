export async function extractRequirements(description) {
  const prompt = `You are a JSON generator. Extract structured requirements and respond ONLY with valid JSON.

Input: "${description}"

Respond with ONLY this JSON structure (no explanation, no markdown, no extra text. Remember to close all brackets):
{
  "appName": "descriptive name for the app",
  "entities": ["list", "of", "data", "models"],
  "roles": ["list", "of", "user", "types"],
  "features": ["list", "of", "app", "features"]
}`;

  let text = "";
  let retries = 0;
  const maxRetries = 3;

  while (retries < maxRetries) {
    try {
      const response = await fetch("http://localhost:11434/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          model: "llama3", 
          prompt, 
          stream: false,
          options: {
            temperature: 0.1,  // Lower temperature for more consistent output
            top_p: 0.9,
            repeat_penalty: 1.1,
            num_predict: 500   // Limit response length
          }
        }),
      });

      const data = await response.json();
      text = data.response.trim();

      let jsonText = text;
    
      const markdownMatch = text.match(/```json\n([\s\S]*?)\n```/) || text.match(/```\n([\s\S]*?)\n```/);
      if (markdownMatch) {
        jsonText = markdownMatch[1];
      } else {
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          jsonText = jsonMatch[0];
        }
      }

      jsonText = jsonText.trim()
        .replace(/,\s*]/g, ']')  
        .replace(/,\s*}/g, '}') 
        .replace(/([^\\])'/g, '$1"')  
        .replace(/^\s*'/g, '"') 
        .replace(/\n/g, ' ')  
        .replace(/\s+/g, ' '); 

      let parsedData;
      try {
        parsedData = JSON.parse(jsonText);
        console.log("Successfully parsed Ollama response:", parsedData);
        return parsedData;  // Success! Return immediately
      } catch (parseError) {
        console.log("First parse failed, attempting JSON repair...");
        
        const coreJsonMatch = jsonText.match(/\{\s*"appName"[\s\S]*?\}\s*$/);
        if (coreJsonMatch) {
          try {
            parsedData = JSON.parse(coreJsonMatch[0]);
            console.log("Successfully parsed after JSON repair:", parsedData);
            return parsedData;  // Success! Return immediately
          } catch (repairError) {
            throw new Error(`JSON repair failed: ${repairError.message}`);
          }
        } else {
          throw new Error(`Cannot extract valid JSON structure: ${parseError.message}`);
        }
      }

    } catch (err) {
      console.error(`Attempt ${retries + 1} failed:`, err.message);
      retries++;
      
      if (retries >= maxRetries) {
        console.error("All retry attempts failed, using fallback");
        break;
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  // If all retries failed, use fallback
  console.error("Failed to parse Ollama output after all retries");
  console.log("Raw Ollama response:", text);

  const entities = [];
  if (description.toLowerCase().includes("student")) entities.push("Student");
  if (description.toLowerCase().includes("course")) entities.push("Course");
  if (description.toLowerCase().includes("grade")) entities.push("Grade");

  const roles = [];
  if (description.toLowerCase().includes("teacher")) roles.push("Teacher");
  if (description.toLowerCase().includes("student")) roles.push("Student");
  if (description.toLowerCase().includes("admin")) roles.push("Admin");

  return {
    appName: "AutoGeneratedApp",
    entities: entities.length ? entities : ["Entity1", "Entity2"],
    roles: roles.length ? roles : ["Role1", "Role2"],
    features: ["Feature1", "Feature2"]
  };
}
